#!/usr/bin/env python3
"""
Supply Chain Data Extraction Agent

This agent is responsible for:
1. Extracting supply chain data from multiple real-time API sources
2. Transforming the data into a unified format
3. Storing the processed data for use by other agents

Author: [Your Name]
Date: April 03, 2025
"""

import sys
import os
import time
import json
import logging
import pandas as pd
import numpy as np
from datetime import datetime, timedelta
import requests
from requests.exceptions import RequestException
import sqlite3
from typing import Dict, List, Any, Optional, Union
import random

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler("data_extraction_agent.log"),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger("DataExtractionAgent")

class APIClient:
    """Base class for API interactions with rate limiting and error handling"""
    
    def __init__(self, base_url: str, api_key: Optional[str] = None, 
                 rate_limit: int = 1, rate_period: int = 1):
        """
        Initialize the API client
        
        Args:
            base_url: Base URL for the API
            api_key: API key for authentication (if required)
            rate_limit: Maximum number of requests in rate_period
            rate_period: Time period in seconds for rate limiting
        """
        self.base_url = base_url
        self.api_key = api_key
        self.rate_limit = rate_limit
        self.rate_period = rate_period
        self.last_request_time = 0
        self.session = requests.Session()
        
        if api_key:
            self.session.headers.update({"X-Api-Key": api_key})
        
        logger.info(f"Initialized API client for {base_url}")
    
    def _respect_rate_limit(self):
        """Ensure rate limits are respected by adding delays if necessary"""
        current_time = time.time()
        time_since_last_request = current_time - self.last_request_time
        
        if time_since_last_request < self.rate_period / self.rate_limit:
            sleep_time = (self.rate_period / self.rate_limit) - time_since_last_request
            logger.debug(f"Rate limit: sleeping for {sleep_time:.2f} seconds")
            time.sleep(sleep_time)
        
        self.last_request_time = time.time()
    
    def request(self, endpoint: str, method: str = "GET", params: Dict = None, 
                data: Dict = None, headers: Dict = None, retries: int = 3) -> Dict:
        """
        Make an API request with rate limiting and error handling
        
        Args:
            endpoint: API endpoint to call
            method: HTTP method (GET, POST, etc.)
            params: Query parameters
            data: Request body for POST/PUT
            headers: Additional headers
            retries: Number of retry attempts for failed requests
            
        Returns:
            API response as dictionary
        """
        url = f"{self.base_url}/{endpoint}"
        attempt = 0
        
        while attempt < retries:
            try:
                self._respect_rate_limit()
                
                response = self.session.request(
                    method=method,
                    url=url,
                    params=params,
                    json=data,
                    headers=headers
                )
                
                response.raise_for_status()
                return response.json()
                
            except RequestException as e:
                attempt += 1
                wait_time = 2 ** attempt  # Exponential backoff
                
                if attempt < retries:
                    logger.warning(f"Request failed: {str(e)}. Retrying in {wait_time} seconds...")
                    time.sleep(wait_time)
                else:
                    logger.error(f"Request failed after {retries} attempts: {str(e)}")
                    raise
        
        return {}  # Should never reach here due to raise in except block


class OpenSkyNetworkAPI(APIClient):
    """Client for OpenSky Network API - provides global flight tracking data"""
    
    def __init__(self, username: Optional[str] = None, password: Optional[str] = None):
        """Initialize OpenSky Network API client"""
        super().__init__(
            base_url="https://opensky-network.org/api",
            rate_limit=10,  # Free tier limit
            rate_period=60
        )
        self.auth = (username, password) if username and password else None
    
    def get_flights(self, begin_time: Optional[int] = None, end_time: Optional[int] = None,
                    airport: Optional[str] = None) -> Dict:
        """
        Get flight data for supply chain transportation tracking
        
        Args:
            begin_time: Start time as Unix timestamp (optional)
            end_time: End time as Unix timestamp (optional)
            airport: ICAO airport code (optional)
            
        Returns:
            Flight data
        """
        try:
            # By default, get flights from the last hour
            if not begin_time:
                begin_time = int((datetime.now() - timedelta(hours=1)).timestamp())
            if not end_time:
                end_time = int(datetime.now().timestamp())
            
            logger.info(f"Fetching flights data from {datetime.fromtimestamp(begin_time)} to {datetime.fromtimestamp(end_time)}")
            
            endpoint = "flights/all"
            params = {
                "begin": begin_time,
                "end": end_time
            }
            
            if airport:
                endpoint = f"flights/arrival"
                params["airport"] = airport
            
            response = requests.get(
                f"{self.base_url}/{endpoint}",
                params=params,
                auth=self.auth
            )
            
            response.raise_for_status()
            return response.json()
            
        except Exception as e:
            logger.error(f"Error fetching flights data: {str(e)}")
            return {}
    
    def get_states(self) -> Dict:
        """
        Get current aircraft state vectors (positions)
        
        Returns:
            Current aircraft positions
        """
        try:
            logger.info("Fetching current aircraft positions")
            
            endpoint = "states/all"
            
            response = requests.get(
                f"{self.base_url}/{endpoint}",
                auth=self.auth
            )
            
            response.raise_for_status()
            return response.json()
            
        except Exception as e:
            logger.error(f"Error fetching aircraft positions: {str(e)}")
            return {}


class ExchangeRatesAPI(APIClient):
    """Client for Exchange Rates API - provides currency exchange data for global supply chains"""
    
    def __init__(self, api_key: Optional[str] = None):
        """Initialize Exchange Rates API client"""
        super().__init__(
            base_url="https://api.exchangerate.host",
            api_key=api_key,
            rate_limit=10,
            rate_period=60
        )
    
    def get_latest_rates(self, base_currency: str = "USD") -> Dict:
        """
        Get latest exchange rates
        
        Args:
            base_currency: Base currency code
            
        Returns:
            Exchange rate data
        """
        try:
            logger.info(f"Fetching latest exchange rates with base {base_currency}")
            
            endpoint = "latest"
            params = {
                "base": base_currency
            }
            
            response = requests.get(
                f"{self.base_url}/{endpoint}",
                params=params
            )
            
            response.raise_for_status()
            return response.json()
            
        except Exception as e:
            logger.error(f"Error fetching exchange rates: {str(e)}")
            return {}
    
    def get_historical_rates(self, date: str, base_currency: str = "USD") -> Dict:
        """
        Get historical exchange rates
        
        Args:
            date: Date in YYYY-MM-DD format
            base_currency: Base currency code
            
        Returns:
            Historical exchange rate data
        """
        try:
            logger.info(f"Fetching historical exchange rates for {date} with base {base_currency}")
            
            endpoint = date
            params = {
                "base": base_currency
            }
            
            response = requests.get(
                f"{self.base_url}/{endpoint}",
                params=params
            )
            
            response.raise_for_status()
            return response.json()
            
        except Exception as e:
            logger.error(f"Error fetching historical exchange rates: {str(e)}")
            return {}


class WeatherAPI(APIClient):
    """Client for OpenWeatherMap API - provides weather data for supply chain risk analysis"""
    
    def __init__(self, api_key: Optional[str] = None):
        """Initialize OpenWeatherMap API client"""
        super().__init__(
            base_url="https://api.openweathermap.org/data/2.5",
            api_key=api_key,
            rate_limit=10,
            rate_period=60
        )
    
    def get_current_weather(self, city: str, country_code: Optional[str] = None) -> Dict:
        """
        Get current weather data for a location
        
        Args:
            city: City name
            country_code: ISO 3166 country code (optional)
            
        Returns:
            Current weather data
        """
        try:
            location = city
            if country_code:
                location = f"{city},{country_code}"
                
            logger.info(f"Fetching current weather for {location}")
            
            endpoint = "weather"
            params = {
                "q": location,
                "units": "metric",
                "appid": self.api_key
            }
            
            response = requests.get(
                f"{self.base_url}/{endpoint}",
                params=params
            )
            
            response.raise_for_status()
            return response.json()
            
        except Exception as e:
            logger.error(f"Error fetching weather data: {str(e)}")
            return {}
    
    def get_forecast(self, city: str, country_code: Optional[str] = None) -> Dict:
        """
        Get 5-day weather forecast for a location
        
        Args:
            city: City name
            country_code: ISO 3166 country code (optional)
            
        Returns:
            Weather forecast data
        """
        try:
            location = city
            if country_code:
                location = f"{city},{country_code}"
                
            logger.info(f"Fetching weather forecast for {location}")
            
            endpoint = "forecast"
            params = {
                "q": location,
                "units": "metric",
                "appid": self.api_key
            }
            
            response = requests.get(
                f"{self.base_url}/{endpoint}",
                params=params
            )
            
            response.raise_for_status()
            return response.json()
            
        except Exception as e:
            logger.error(f"Error fetching weather forecast: {str(e)}")
            return {}


class DataTransformer:
    """Transforms raw API data into a unified format for analysis"""
    
    def transform_flight_data(self, flight_data: List) -> pd.DataFrame:
        """
        Transform flight data into a DataFrame for logistics analysis
        
        Args:
            flight_data: Raw flight data from OpenSky Network API
            
        Returns:
            Pandas DataFrame with transformed data
        """
        try:
            if not flight_data:
                return pd.DataFrame()
            
            # Create DataFrame
            df = pd.DataFrame(flight_data)
            
            # Convert timestamps to datetime
            if 'firstSeen' in df.columns:
                df['firstSeen'] = pd.to_datetime(df['firstSeen'], unit='s')
            if 'lastSeen' in df.columns:
                df['lastSeen'] = pd.to_datetime(df['lastSeen'], unit='s')
            
            # Calculate flight duration if possible
            if 'firstSeen' in df.columns and 'lastSeen' in df.columns:
                df['duration_hours'] = (df['lastSeen'] - df['firstSeen']).dt.total_seconds() / 3600
            
            return df
            
        except Exception as e:
            logger.error(f"Error transforming flight data: {str(e)}")
            return pd.DataFrame()
    
    def transform_exchange_rate_data(self, exchange_data: Dict) -> pd.DataFrame:
        """
        Transform exchange rate data into a DataFrame
        
        Args:
            exchange_data: Raw exchange rate data
            
        Returns:
            Pandas DataFrame with transformed data
        """
        try:
            if not exchange_data or 'rates' not in exchange_data:
                return pd.DataFrame()
            
            # Extract data from response
            base_currency = exchange_data.get('base', 'USD')
            date = exchange_data.get('date', datetime.now().strftime('%Y-%m-%d'))
            rates = exchange_data.get('rates', {})
            
            # Create DataFrame
            data = []
            for currency, rate in rates.items():
                data.append({
                    'date': date,
                    'base_currency': base_currency,
                    'target_currency': currency,
                    'exchange_rate': rate
                })
            
            df = pd.DataFrame(data)
            
            # Convert date to datetime
            df['date'] = pd.to_datetime(df['date'])
            
            return df
            
        except Exception as e:
            logger.error(f"Error transforming exchange rate data: {str(e)}")
            return pd.DataFrame()
    
    def transform_weather_data(self, weather_data: Dict) -> pd.DataFrame:
        """
        Transform weather data into a DataFrame
        
        Args:
            weather_data: Raw weather data
            
        Returns:
            Pandas DataFrame with transformed data
        """
        try:
            if not weather_data or 'name' not in weather_data:
                return pd.DataFrame()
            
            # Extract main weather data
            city = weather_data.get('name', '')
            country = weather_data.get('sys', {}).get('country', '')
            timestamp = weather_data.get('dt', 0)
            
            main_data = weather_data.get('main', {})
            temperature = main_data.get('temp', 0)
            feels_like = main_data.get('feels_like', 0)
            humidity = main_data.get('humidity', 0)
            pressure = main_data.get('pressure', 0)
            
            weather_desc = weather_data.get('weather', [{}])[0].get('description', '')
            
            wind_data = weather_data.get('wind', {})
            wind_speed = wind_data.get('speed', 0)
            wind_direction = wind_data.get('deg', 0)
            
            # Create DataFrame
            data = [{
                'city': city,
                'country': country,
                'timestamp': pd.to_datetime(timestamp, unit='s'),
                'temperature': temperature,
                'feels_like': feels_like,
                'humidity': humidity,
                'pressure': pressure,
                'weather_description': weather_desc,
                'wind_speed': wind_speed,
                'wind_direction': wind_direction
            }]
            
            df = pd.DataFrame(data)
            
            return df
            
        except Exception as e:
            logger.error(f"Error transforming weather data: {str(e)}")
            return pd.DataFrame()
    
    def transform_weather_forecast(self, forecast_data: Dict) -> pd.DataFrame:
        """
        Transform weather forecast data into a DataFrame
        
        Args:
            forecast_data: Raw weather forecast data
            
        Returns:
            Pandas DataFrame with transformed data
        """
        try:
            if not forecast_data or 'list' not in forecast_data:
                return pd.DataFrame()
            
            # Extract city info
            city_data = forecast_data.get('city', {})
            city = city_data.get('name', '')
            country = city_data.get('country', '')
            
            # Process forecast entries
            forecast_entries = forecast_data.get('list', [])
            data = []
            
            for entry in forecast_entries:
                timestamp = entry.get('dt', 0)
                main_data = entry.get('main', {})
                
                weather_desc = ''
                if entry.get('weather') and len(entry.get('weather')) > 0:
                    weather_desc = entry['weather'][0].get('description', '')
                
                wind_data = entry.get('wind', {})
                
                data.append({
                    'city': city,
                    'country': country,
                    'timestamp': pd.to_datetime(timestamp, unit='s'),
                    'temperature': main_data.get('temp', 0),
                    'feels_like': main_data.get('feels_like', 0),
                    'humidity': main_data.get('humidity', 0),
                    'pressure': main_data.get('pressure', 0),
                    'weather_description': weather_desc,
                    'wind_speed': wind_data.get('speed', 0),
                    'wind_direction': wind_data.get('deg', 0)
                })
            
            df = pd.DataFrame(data)
            
            return df
            
        except Exception as e:
            logger.error(f"Error transforming weather forecast data: {str(e)}")
            return pd.DataFrame()


class DataStorage:
    """Handles storage and retrieval of processed data"""
    
    def __init__(self, db_path: str = "supply_chain_data.db"):
        """
        Initialize the data storage
        
        Args:
            db_path: Path to the SQLite database file
        """
        self.db_path = db_path
        self._initialize_database()
        logger.info(f"Initialized data storage with database at {db_path}")
    
    def _initialize_database(self):
        """Create database tables if they don't exist"""
        try:
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            
            # Create tables for different data types
            cursor.execute('''
            CREATE TABLE IF NOT EXISTS flight_data (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                icao24 TEXT,
                callsign TEXT,
                origin_country TEXT,
                firstSeen TIMESTAMP,
                lastSeen TIMESTAMP,
                departure_airport TEXT,
                arrival_airport TEXT,
                duration_hours REAL,
                created_at TEXT
            )
            ''')
            
            cursor.execute('''
            CREATE TABLE IF NOT EXISTS exchange_rates (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                date TEXT,
                base_currency TEXT,
                target_currency TEXT,
                exchange_rate REAL,
                created_at TEXT
            )
            ''')
            
            cursor.execute('''
            CREATE TABLE IF NOT EXISTS weather_data (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                city TEXT,
                country TEXT,
                timestamp TIMESTAMP,
                temperature REAL,
                feels_like REAL,
                humidity REAL,
                pressure REAL,
                weather_description TEXT,
                wind_speed REAL,
                wind_direction REAL,
                forecast BOOLEAN,
                created_at TEXT
            )
            ''')
            
            conn.commit()
            conn.close()
            
        except Exception as e:
            logger.error(f"Error initializing database: {str(e)}")
    
    def store_flight_data(self, df: pd.DataFrame):
        """
        Store flight data in the database
        
        Args:
            df: DataFrame containing flight data
        """
        if df.empty:
            logger.warning("Attempted to store empty flight data")
            return
        
        try:
            conn = sqlite3.connect(self.db_path)
            
            # Add creation timestamp
            df["created_at"] = datetime.now().isoformat()
            
            # Store in database
            df.to_sql("flight_data", conn, if_exists="append", index=False)
            
            conn.close()
            logger.info(f"Stored {len(df)} flight data records")
            
        except Exception as e:
            logger.error(f"Error storing flight data: {str(e)}")
    
    def store_exchange_rate_data(self, df: pd.DataFrame):
        """
        Store exchange rate data in the database
        
        Args:
            df: DataFrame containing exchange rate data
        """
        if df.empty:
            logger.warning("Attempted to store empty exchange rate data")
            return
        
        try:
            conn = sqlite3.connect(self.db_path)
            
            # Add creation timestamp
            df["created_at"] = datetime.now().isoformat()
            
            # Store in database
            df.to_sql("exchange_rates", conn, if_exists="append", index=False)
            
            conn.close()
            logger.info(f"Stored {len(df)} exchange rate records")
            
        except Exception as e:
            logger.error(f"Error storing exchange rate data: {str(e)}")
    
    def store_weather_data(self, df: pd.DataFrame, is_forecast: bool = False):
        """
        Store weather data in the database
        
        Args:
            df: DataFrame containing weather data
            is_forecast: Whether the data is a forecast
        """
        if df.empty:
            logger.warning("Attempted to store empty weather data")
            return
        
        try:
            conn = sqlite3.connect(self.db_path)
            
            # Add creation timestamp and forecast flag
            df["created_at"] = datetime.now().isoformat()
            df["forecast"] = is_forecast
            
            # Store in database
            df.to_sql("weather_data", conn, if_exists="append", index=False)
            
            conn.close()
            logger.info(f"Stored {len(df)} weather data records")
            
        except Exception as e:
            logger.error(f"Error storing weather data: {str(e)}")
    
    def get_latest_data(self, table_name: str, limit: int = 100) -> pd.DataFrame:
        """
        Retrieve the latest data from a table
        
        Args:
            table_name: Name of the table to query
            limit: Maximum number of records to retrieve
            
        Returns:
            DataFrame containing the latest data
        """
        try:
            conn = sqlite3.connect(self.db_path)
            
            query = f"SELECT * FROM {table_name} ORDER BY id DESC LIMIT {limit}"
            df = pd.read_sql_query(query, conn)
            
            conn.close()
            logger.info(f"Retrieved {len(df)} records from {table_name}")
            
            return df
            
        except Exception as e:
            logger.error(f"Error retrieving data from {table_name}: {str(e)}")
            return pd.DataFrame()


class DataExtractionAgent:
    """
    Main agent class for supply chain data extraction
    
    This agent extracts data from various APIs relevant to supply chain
    operations and stores it in a SQLite database for analysis.
    """
    
    def __init__(self, config_path: Optional[str] = None):
        """
        Initialize the Data Extraction Agent
        
        Args:
            config_path: Path to configuration file (optional)
        """
        # Load configuration if provided
        self.config = self._load_config(config_path)
        
        # Initialize API clients
        self.opensky_api = OpenSkyNetworkAPI(
            username=self.config.get("opensky_username"),
            password=self.config.get("opensky_password")
        )
        
        self.exchange_api = ExchangeRatesAPI(
            api_key=self.config.get("exchange_api_key")
        )
        
        self.weather_api = WeatherAPI(
            api_key=self.config.get("openweather_api_key")
        )
        
        # Initialize data transformer
        self.transformer = DataTransformer()
        
        # Initialize data storage
        self.storage = DataStorage(db_path=self.config.get("db_path", "supply_chain_data.db"))
        
        # Set up locations to track
        self.supply_chain_locations = self.config.get("supply_chain_locations", [
            {"city": "Shanghai", "country": "CN", "airport": "ZSPD"},
            {"city": "Singapore", "country": "SG", "airport": "WSSS"},
            {"city": "Rotterdam", "country": "NL", "airport": "EHRD"},
            {"city": "Los Angeles", "country": "US", "airport": "KLAX"},
            {"city": "New York", "country": "US", "airport": "KJFK"}
        ])
        
        logger.info("Data Extraction Agent initialized for supply chain analytics")
    
    def _load_config(self, config_path: Optional[str]) -> Dict:
        """
        Load configuration from file
        
        Args:
            config_path: Path to configuration file
            
        Returns:
            Configuration dictionary
        """
        default_config = {
            "opensky_username": None,
            "opensky_password": None,
            "exchange_api_key": None,
            "openweather_api_key": None,
            "db_path": "supply_chain_data.db",
            "supply_chain_locations": [
                {"city": "Shanghai", "country": "CN", "airport": "ZSPD"},
                {"city": "Singapore", "country": "SG", "airport": "WSSS"},
                {"city": "Rotterdam", "country": "NL", "airport": "EHRD"},
                {"city": "Los Angeles", "country": "US", "airport": "KLAX"},
                {"city": "New York", "country": "US", "airport": "KJFK"}
            ]
        }
        
        if config_path and os.path.exists(config_path):
            try:
                with open(config_path, "r") as f:
                    config = json.load(f)
                    # Update default config with loaded values
                    default_config.update(config)
                logger.info(f"Loaded configuration from {config_path}")
            except Exception as e:
                logger.error(f"Error loading configuration from {config_path}: {str(e)}")
        
        return default_config
    
    def extract_flight_data(self):
        """Extract and store flight data for supply chain logistics"""
        logger.info("Starting extraction of flight data for supply chain logistics")
        
        for location in self.supply_chain_locations:
            airport = location.get("airport")
            if airport:
                try:
                    # Get flight data for this location
                    flight_data = self.opensky_api.get_flights(airport=airport)
                    
                    # Transform data
                    df = self.transformer.transform_flight_data(flight_data)
                    
                    # Store data
                    if not df.empty:
                        self.storage.store_flight_data(df)
                        logger.info(f"Successfully extracted and stored flight data for {airport}")
                    else:
                        logger.warning(f"No flight data retrieved for {airport}")
                    
                except Exception as e:
                    logger.error(f"Error processing flight data for {airport}: {str(e)}")
    
    def extract_exchange_rate_data(self):
        """Extract and store exchange rate data for financial risk analysis"""
        logger.info("Starting extraction of exchange rate data for financial risk analysis")
        
        try:
            # Get latest exchange rates
            exchange_data = self.exchange_api.get_latest_rates()
            
            # Transform data
            df = self.transformer.transform_exchange_rate_data(exchange_data)
            
            # Store data
            if not df.empty:
                self.storage.store_exchange_rate_data(df)
                logger.info("Successfully extracted and stored exchange rate data")
            else:
                logger.warning("No exchange rate data retrieved")
            
            # Get historical rates for the past week
            for i in range(1, 8):
                date = (datetime.now() - timedelta(days=i)).strftime('%Y-%m-%d')
                historical_data = self.exchange_api.get_historical_rates(date=date)
                
                # Transform and store historical data
                hist_df = self.transformer.transform_exchange_rate_data(historical_data)
                
                if not hist_df.empty:
                    self.storage.store_exchange_rate_data(hist_df)
                    logger.info(f"Successfully extracted and stored historical exchange rate data for {date}")
                else:
                    logger.warning(f"No historical exchange rate data retrieved for {date}")
                
                # Respect API rate limits
                time.sleep(1)
            
        except Exception as e:
            logger.error(f"Error processing exchange rate data: {str(e)}")
    
    def extract_weather_data(self):
        """Extract and store weather data for supply chain risk analysis"""
        logger.info("Starting extraction of weather data for supply chain risk analysis")
        
        for location in self.supply_chain_locations:
            city = location.get("city")
            country = location.get("country")
            
            if city:
                try:
                    # Get current weather for this location
                    weather_data = self.weather_api.get_current_weather(city=city, country_code=country)
                    
                    # Transform data
                    df = self.transformer.transform_weather_data(weather_data)
                    
                    # Store data
                    if not df.empty:
                        self.storage.store_weather_data(df, is_forecast=False)
                        logger.info(f"Successfully extracted and stored current weather data for {city}")
                    else:
                        logger.warning(f"No current weather data retrieved for {city}")
                    
                    # Get forecast for this location
                    forecast_data = self.weather_api.get_forecast(city=city, country_code=country)
                    
                    # Transform data
                    forecast_df = self.transformer.transform_weather_forecast(forecast_data)
                    
                    # Store data
                    if not forecast_df.empty:
                        self.storage.store_weather_data(forecast_df, is_forecast=True)
                        logger.info(f"Successfully extracted and stored weather forecast data for {city}")
                    else:
                        logger.warning(f"No weather forecast data retrieved for {city}")
                    
                except Exception as e:
                    logger.error(f"Error processing weather data for {city}: {str(e)}")
                
                # Respect API rate limits
                time.sleep(1)
    
    def extract_all_data(self):
        """Extract and store all types of data"""
        logger.info("Starting extraction of all supply chain data")
        
        self.extract_flight_data()
        self.extract_exchange_rate_data()
        self.extract_weather_data()
        
        logger.info("Completed extraction of all supply chain data")
    
    def get_data_for_analysis(self) -> Dict[str, pd.DataFrame]:
        """
        Retrieve the latest data for analysis
        
        Returns:
            Dictionary of DataFrames containing the latest data for each type
        """
        logger.info("Retrieving data for analysis")
        
        data = {
            "flight_data": self.storage.get_latest_data("flight_data"),
            "exchange_rates": self.storage.get_latest_data("exchange_rates"),
            "weather_data": self.storage.get_latest_data("weather_data")
        }
        
        return data


def main():
    """Main function to run the Data Extraction Agent"""
    try:
        # Initialize the agent
        agent = DataExtractionAgent()
        
        # Extract all data
        agent.extract_all_data()
        
        # Get the data for analysis
        data = agent.get_data_for_analysis()
        
        # Print summary of extracted data
        for data_type, df in data.items():
            if not df.empty:
                print(f"{data_type}: {len(df)} records")
                # Show a sample
                print("Sample data:")
                print(df.head(2))
                print()
            else:
                print(f"{data_type}: No data")
        
        print("\nSupply chain data extraction completed successfully.")
        print("The extracted data is stored in the database and ready for analysis.")
        
    except Exception as e:
        logger.error(f"Error in main function: {str(e)}")
        print(f"Error: {str(e)}")


# Simulated API response functions for testing purposes
# These functions allow testing the code without actual API keys
def simulate_flight_data():
    """Generate simulated flight data for testing"""
    airports = ["ZSPD", "WSSS", "EHRD", "KLAX", "KJFK"]
    airlines = ["CPA", "SIA", "KLM", "AAL", "UAL", "FDX", "UPS"]
    countries = ["CN", "SG", "NL", "US", "JP", "KR", "DE", "GB"]
    
    current_time = int(datetime.now().timestamp())
    one_hour_ago = current_time - 3600
    
    flights = []
    for _ in range(50):  # Generate 50 random flights
        dep_airport = random.choice(airports)
        arr_airport = random.choice([a for a in airports if a != dep_airport])
        
        # Generate random timestamps
        first_seen = random.randint(one_hour_ago - 86400, one_hour_ago)  # Within the last day
        flight_duration = random.randint(3600, 36000)  # 1 to 10 hours
        last_seen = first_seen + flight_duration
        
        flight = {
            "icao24": ''.join(random.choices('0123456789ABCDEF', k=6)),
            "callsign": random.choice(airlines) + str(random.randint(100, 999)),
            "origin_country": random.choice(countries),
            "firstSeen": first_seen,
            "lastSeen": last_seen,
            "departure_airport": dep_airport,
            "arrival_airport": arr_airport
        }
        flights.append(flight)
    
    return flights

def simulate_exchange_rates():
    """Generate simulated exchange rate data for testing"""
    base = "USD"
    currencies = ["EUR", "GBP", "JPY", "CNY", "SGD", "AUD", "CAD", "CHF", "HKD", "KRW"]
    
    rates = {}
    for currency in currencies:
        # Create realistic but randomized exchange rates
        if currency == "EUR":
            rates[currency] = round(random.uniform(0.85, 0.95), 6)
        elif currency == "GBP":
            rates[currency] = round(random.uniform(0.75, 0.85), 6)
        elif currency == "JPY":
            rates[currency] = round(random.uniform(105.0, 115.0), 6)
        elif currency == "CNY":
            rates[currency] = round(random.uniform(6.3, 6.5), 6)
        elif currency == "SGD":
            rates[currency] = round(random.uniform(1.3, 1.4), 6)
        else:
            rates[currency] = round(random.uniform(0.5, 2.0), 6)
    
    result = {
        "success": True,
        "timestamp": int(datetime.now().timestamp()),
        "base": base,
        "date": datetime.now().strftime("%Y-%m-%d"),
        "rates": rates
    }
    
    return result

def simulate_weather_data(city, country):
    """Generate simulated weather data for testing"""
    # Create realistic temperature ranges based on location
    temp_ranges = {
        "Shanghai": (5, 35),
        "Singapore": (25, 35),
        "Rotterdam": (0, 25),
        "Los Angeles": (15, 30),
        "New York": (-5, 30)
    }
    
    # Default temperature range
    temp_range = (0, 30)
    if city in temp_ranges:
        temp_range = temp_ranges[city]
    
    # Generate random weather data
    temperature = round(random.uniform(temp_range[0], temp_range[1]), 1)
    
    weather_conditions = ["clear sky", "few clouds", "scattered clouds", 
                          "broken clouds", "shower rain", "rain", 
                          "thunderstorm", "snow", "mist"]
    
    weather = {
        "coord": {"lon": random.uniform(-180, 180), "lat": random.uniform(-90, 90)},
        "weather": [
            {
                "id": random.randint(200, 800),
                "main": "Weather",
                "description": random.choice(weather_conditions),
                "icon": "01d"
            }
        ],
        "main": {
            "temp": temperature,
            "feels_like": temperature - random.uniform(-2, 2),
            "temp_min": temperature - random.uniform(0, 5),
            "temp_max": temperature + random.uniform(0, 5),
            "pressure": random.randint(990, 1030),
            "humidity": random.randint(30, 90)
        },
        "visibility": random.randint(5000, 10000),
        "wind": {
            "speed": random.uniform(0, 15),
            "deg": random.randint(0, 359)
        },
        "clouds": {
            "all": random.randint(0, 100)
        },
        "dt": int(datetime.now().timestamp()),
        "sys": {
            "type": 1,
            "id": random.randint(1000, 9999),
            "country": country,
            "sunrise": int((datetime.now().replace(hour=6, minute=0, second=0)).timestamp()),
            "sunset": int((datetime.now().replace(hour=18, minute=0, second=0)).timestamp())
        },
        "timezone": random.randint(-43200, 43200),
        "id": random.randint(1000000, 9999999),
        "name": city,
        "cod": 200
    }
    
    return weather

def simulate_weather_forecast(city, country):
    """Generate simulated weather forecast data for testing"""
    forecast = {
        "cod": "200",
        "message": 0,
        "cnt": 40,
        "list": [],
        "city": {
            "id": random.randint(1000000, 9999999),
            "name": city,
            "country": country,
            "population": random.randint(100000, 10000000),
            "timezone": random.randint(-43200, 43200),
            "sunrise": int((datetime.now().replace(hour=6, minute=0, second=0)).timestamp()),
            "sunset": int((datetime.now().replace(hour=18, minute=0, second=0)).timestamp())
        }
    }
    
    # Generate forecast entries for the next 5 days, 3-hour intervals
    current_time = datetime.now()
    for i in range(40):
        forecast_time = current_time + timedelta(hours=i*3)
        
        # Get base weather for this city
        base_weather = simulate_weather_data(city, country)
        
        # Add some variation for the forecast
        temp_variation = random.uniform(-5, 5)
        
        entry = {
            "dt": int(forecast_time.timestamp()),
            "main": {
                "temp": base_weather["main"]["temp"] + temp_variation,
                "feels_like": base_weather["main"]["feels_like"] + temp_variation,
                "temp_min": base_weather["main"]["temp_min"] + temp_variation,
                "temp_max": base_weather["main"]["temp_max"] + temp_variation,
                "pressure": base_weather["main"]["pressure"] + random.randint(-10, 10),
                "humidity": base_weather["main"]["humidity"] + random.randint(-10, 10)
            },
            "weather": base_weather["weather"],
            "wind": {
                "speed": base_weather["wind"]["speed"] + random.uniform(-2, 2),
                "deg": random.randint(0, 359)
            }
        }
        
        forecast["list"].append(entry)
    
    return forecast


class TestingAPIClient:
    """Test implementation for when real API keys are not available"""
    
    @staticmethod
    def test_opensky_api():
        """Test the OpenSky API client with simulated data"""
        print("Testing OpenSky Network API client...")
        
        # Create a mock implementation of the API
        class MockOpenSkyAPI(OpenSkyNetworkAPI):
            def get_flights(self, begin_time=None, end_time=None, airport=None):
                return simulate_flight_data()
            
            def get_states(self):
                return {"states": []}
        
        # Initialize and test the mock API
        api = MockOpenSkyAPI()
        flights = api.get_flights()
        
        print(f"Retrieved {len(flights)} simulated flights")
        if flights:
            print("Sample flight data:")
            print(json.dumps(flights[0], indent=2))
        
        return flights
    
    @staticmethod
    def test_exchange_api():
        """Test the Exchange Rates API client with simulated data"""
        print("Testing Exchange Rates API client...")
        
        # Create a mock implementation of the API
        class MockExchangeAPI(ExchangeRatesAPI):
            def get_latest_rates(self, base_currency="USD"):
                return simulate_exchange_rates()
            
            def get_historical_rates(self, date, base_currency="USD"):
                result = simulate_exchange_rates()
                result["date"] = date
                return result
        
        # Initialize and test the mock API
        api = MockExchangeAPI()
        rates = api.get_latest_rates()
        
        print(f"Retrieved exchange rates for {len(rates.get('rates', {}))} currencies")
        print("Sample exchange rate data:")
        print(json.dumps(rates, indent=2))
        
        return rates
    
    @staticmethod
    def test_weather_api():
        """Test the Weather API client with simulated data"""
        print("Testing Weather API client...")
        
        # Create a mock implementation of the API
        class MockWeatherAPI(WeatherAPI):
            def get_current_weather(self, city, country_code=None):
                return simulate_weather_data(city, country_code)
            
            def get_forecast(self, city, country_code=None):
                return simulate_weather_forecast(city, country_code)
        
        # Initialize and test the mock API
        api = MockWeatherAPI()
        weather = api.get_current_weather("Shanghai", "CN")
        forecast = api.get_forecast("Shanghai", "CN")
        
        print("Retrieved current weather data:")
        print(json.dumps(weather, indent=2))
        
        print(f"Retrieved forecast with {len(forecast.get('list', []))} time periods")
        
        return weather, forecast


if __name__ == "__main__":
    # Check for API keys in environment or config
    # If not available, use simulated data for testing
    if (os.environ.get("OPENWEATHER_API_KEY") or 
        os.environ.get("EXCHANGE_API_KEY") or 
        os.environ.get("OPENSKY_USERNAME")):
        main()
    else:
        print("No API keys detected. Running in test mode with simulated data.")
        print("To use real APIs, provide API keys in environment or config file.")
        print("\n" + "="*50 + "\n")
        
        # Run the tests with simulated data
        test_client = TestingAPIClient()
        test_client.test_opensky_api()
        print("\n" + "="*50 + "\n")
        test_client.test_exchange_api()
        print("\n" + "="*50 + "\n")
        test_client.test_weather_api()
